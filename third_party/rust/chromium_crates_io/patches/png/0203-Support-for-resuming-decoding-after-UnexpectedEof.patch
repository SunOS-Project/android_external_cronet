From 5efbb60ab8eb1ac928b7ddc1a5946d0ed7f47e7b Mon Sep 17 00:00:00 2001
From: Lukasz Anforowicz <lukasza@chromium.org>
Date: Wed, 4 Sep 2024 02:18:49 +0000
Subject: [PATCH 203/203] Support for resuming decoding after `UnexpectedEof`.

This commit supports resuming decoding after `UnexpectedEof`:

* Before this commit `fn next_interlaced_row` would unconditionally call
  `InterlaceInfoIter.next` - advancing to the next row.  After this
  commit this will only happen after a row has been successfully
  decoded (inside `next_interlaced_row_impl` because advancing needs
  to be synchronized across the public `next_frame` and
  `next_interlaced_row` APIs)..
* Before this commit `fn next_frame` would always start decoding into
  the very beginning of `buf`, even if these initial rows have already
  been successfully decoded earlier.  After this commit an offset is
  calculated based on `InterlaceInfo.line_number`.
* Before this commit `fn next_frame` would always reset `data_stream`,
  `current_start`, and `prev_start`.  After this commit, this got moved
  and only happens inside `read_until_image_data`.
---
 src/decoder/mod.rs    |  30 ++++---
 src/decoder/stream.rs | 181 +++++++++++++++++++++++++++++++++++++++++-
 2 files changed, 200 insertions(+), 11 deletions(-)

diff --git a/third_party/rust/chromium_crates_io/vendor/png-0.17.13/src/decoder/mod.rs b/third_party/rust/chromium_crates_io/vendor/png-0.17.13/src/decoder/mod.rs
index 94a95bb..91adbc9 100644
--- a/third_party/rust/chromium_crates_io/vendor/png-0.17.13/src/decoder/mod.rs
+++ b/third_party/rust/chromium_crates_io/vendor/png-0.17.13/src/decoder/mod.rs
@@ -381,12 +381,13 @@ struct SubframeInfo {
     width: u32,
     height: u32,
     rowlen: usize,
-    interlace: InterlaceInfoIter,
+    current_interlace_info: Option<InterlaceInfo>,
+    interlace_info_iter: InterlaceInfoIter,
     consumed_and_flushed: bool,
 }
 
 /// Denote a frame as given by sequence numbers.
-#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]
+#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
 enum SubframeIdx {
     /// The initial frame in an IDAT chunk without fcTL chunk applying to it.
     /// Note that this variant precedes `Some` as IDAT frames precede fdAT frames and all fdAT
@@ -439,6 +440,9 @@ impl<R: Read> Reader<R> {
             .ok_or(DecodingError::Format(FormatErrorInner::MissingIhdr.into()))?;
         self.bpp = info.bpp_in_prediction();
         self.subframe = SubframeInfo::new(info);
+        self.data_stream.clear();
+        self.current_start = 0;
+        self.prev_start = 0;
 
         // Allocate output buffer.
         let buflen = self.output_line_size(self.subframe.width);
@@ -503,9 +507,6 @@ impl<R: Read> Reader<R> {
             line_size: self.output_line_size(self.subframe.width),
         };
 
-        self.data_stream.clear();
-        self.current_start = 0;
-        self.prev_start = 0;
         if self.info().interlaced {
             let stride = self.output_line_size(self.info().width);
             let samples = color_type.samples() as u8;
@@ -521,9 +522,15 @@ impl<R: Read> Reader<R> {
                 adam7::expand_pass(buf, stride, row, adam7info, bits_pp);
             }
         } else {
+            let current_interlace_info = self.subframe.current_interlace_info.as_ref();
+            let already_done_rows = current_interlace_info
+                .map(|info| info.line_number())
+                .unwrap_or(self.subframe.height);
+
             for row in buf
                 .chunks_exact_mut(output_info.line_size)
                 .take(self.subframe.height as usize)
+                .skip(already_done_rows as usize)
             {
                 self.next_interlaced_row_impl(self.subframe.rowlen, row)?;
             }
@@ -563,9 +570,9 @@ impl<R: Read> Reader<R> {
 
     /// Returns the next processed row of the image
     pub fn next_interlaced_row(&mut self) -> Result<Option<InterlacedRow>, DecodingError> {
-        let interlace = match self.subframe.interlace.next() {
+        let interlace = match self.subframe.current_interlace_info.as_ref() {
             None => return Ok(None),
-            Some(interlace) => interlace,
+            Some(interlace) => *interlace,
         };
         if interlace.line_number() == 0 {
             self.prev_start = self.current_start;
@@ -634,6 +641,7 @@ impl<R: Read> Reader<R> {
         };
         transform_fn(row, output_buffer, self.info());
 
+        self.subframe.current_interlace_info = self.subframe.interlace_info_iter.next();
         Ok(())
     }
 
@@ -745,7 +753,8 @@ impl SubframeInfo {
             width: 0,
             height: 0,
             rowlen: 0,
-            interlace: InterlaceInfoIter::empty(),
+            current_interlace_info: None,
+            interlace_info_iter: InterlaceInfoIter::empty(),
             consumed_and_flushed: false,
         }
     }
@@ -759,11 +768,14 @@ impl SubframeInfo {
             (info.width, info.height)
         };
 
+        let mut interlace_info_iter = InterlaceInfoIter::new(width, height, info.interlaced);
+        let current_interlace_info = interlace_info_iter.next();
         SubframeInfo {
             width,
             height,
             rowlen: info.raw_row_length_from_width(width),
-            interlace: InterlaceInfoIter::new(width, height, info.interlaced),
+            current_interlace_info,
+            interlace_info_iter,
             consumed_and_flushed: false,
         }
     }
diff --git a/third_party/rust/chromium_crates_io/vendor/png-0.17.13/src/decoder/stream.rs b/third_party/rust/chromium_crates_io/vendor/png-0.17.13/src/decoder/stream.rs
index 3b6ccb6..6afaf19 100644
--- a/third_party/rust/chromium_crates_io/vendor/png-0.17.13/src/decoder/stream.rs
+++ b/third_party/rust/chromium_crates_io/vendor/png-0.17.13/src/decoder/stream.rs
@@ -108,6 +108,11 @@ pub enum Decoded {
 #[derive(Debug)]
 pub enum DecodingError {
     /// An error in IO of the underlying reader.
+    ///
+    /// Note that some IO errors may be recoverable - decoding may be retried after the
+    /// error is resolved.  For example, decoding from a slow stream of data (e.g. decoding from a
+    /// network stream) may occasionally result in [std::io::ErrorKind::UnexpectedEof] kind of
+    /// error, but decoding can resume when more data becomes available.
     IoError(io::Error),
     /// The input image was not a valid PNG.
     ///
@@ -1498,10 +1503,12 @@ mod tests {
     use super::ScaledFloat;
     use super::SourceChromaticities;
     use crate::test_utils::*;
-    use crate::{Decoder, DecodingError};
+    use crate::{Decoder, DecodingError, Reader};
     use byteorder::WriteBytesExt;
+    use std::cell::RefCell;
     use std::fs::File;
-    use std::io::Write;
+    use std::io::{ErrorKind, Read, Write};
+    use std::rc::Rc;
 
     #[test]
     fn image_gamma() -> Result<(), ()> {
@@ -1964,4 +1971,174 @@ mod tests {
         reader.next_frame(&mut buf).unwrap();
         assert_eq!(3093270825, crc32fast::hash(&buf));
     }
+
+    /// `StremingInput` can be used by tests to simulate a streaming input
+    /// (e.g. a slow http response, where all bytes are not immediately available).
+    #[derive(Clone)]
+    struct StreamingInput(Rc<RefCell<StreamingInputState>>);
+
+    struct StreamingInputState {
+        full_input: Vec<u8>,
+        current_pos: usize,
+        available_len: usize,
+    }
+
+    impl StreamingInput {
+        fn new(full_input: Vec<u8>) -> Self {
+            Self(Rc::new(RefCell::new(StreamingInputState {
+                full_input,
+                current_pos: 0,
+                available_len: 0,
+            })))
+        }
+
+        fn with_noncompressed_png(width: u32, idat_size: usize) -> Self {
+            let mut png = Vec::new();
+            write_noncompressed_png(&mut png, width, idat_size);
+            Self::new(png)
+        }
+
+        fn expose_next_byte(&self) {
+            let mut state = self.0.borrow_mut();
+            assert!(state.available_len < state.full_input.len());
+            state.available_len += 1;
+        }
+
+        fn stream_input_until_reader_is_available(&self) -> Reader<StreamingInput> {
+            loop {
+                self.0.borrow_mut().current_pos = 0;
+                match Decoder::new(self.clone()).read_info() {
+                    Ok(reader) => {
+                        break reader;
+                    }
+                    Err(DecodingError::IoError(e)) if e.kind() == ErrorKind::UnexpectedEof => {
+                        self.expose_next_byte();
+                    }
+                    _ => panic!("Unexpected error"),
+                }
+            }
+        }
+
+        fn decode_full_input<F, R>(&self, f: F) -> R
+        where
+            F: FnOnce(Reader<&[u8]>) -> R,
+        {
+            let state = self.0.borrow();
+            let decoder = Decoder::new(state.full_input.as_slice());
+            f(decoder.read_info().unwrap())
+        }
+    }
+
+    impl Read for StreamingInput {
+        fn read(&mut self, buf: &mut [u8]) -> std::io::Result<usize> {
+            let mut state = self.0.borrow_mut();
+            let mut available_bytes = &state.full_input[state.current_pos..state.available_len];
+            let number_of_read_bytes = available_bytes.read(buf)?;
+            state.current_pos += number_of_read_bytes;
+            assert!(state.current_pos <= state.available_len);
+            Ok(number_of_read_bytes)
+        }
+    }
+
+    /// Test resuming/retrying `Reader.next_frame` after `UnexpectedEof`.
+    #[test]
+    fn test_streaming_input_and_decoding_via_next_frame() {
+        const WIDTH: u32 = 16;
+        const IDAT_SIZE: usize = 512;
+        let streaming_input = StreamingInput::with_noncompressed_png(WIDTH, IDAT_SIZE);
+
+        let (whole_output_info, decoded_from_whole_input) =
+            streaming_input.decode_full_input(|mut r| {
+                let mut buf = vec![0; r.output_buffer_size()];
+                let output_info = r.next_frame(&mut buf).unwrap();
+                (output_info, buf)
+            });
+
+        let mut png_reader = streaming_input.stream_input_until_reader_is_available();
+        let mut decoded_from_streaming_input = vec![0; png_reader.output_buffer_size()];
+        let streaming_output_info = loop {
+            match png_reader.next_frame(decoded_from_streaming_input.as_mut_slice()) {
+                Ok(output_info) => break output_info,
+                Err(DecodingError::IoError(e)) if e.kind() == ErrorKind::UnexpectedEof => {
+                    streaming_input.expose_next_byte()
+                }
+                e => panic!("Unexpected error: {:?}", e),
+            }
+        };
+        assert_eq!(whole_output_info, streaming_output_info);
+        assert_eq!(
+            crc32fast::hash(&decoded_from_whole_input),
+            crc32fast::hash(&decoded_from_streaming_input)
+        );
+    }
+
+    /// Test resuming/retrying `Reader.next_row` after `UnexpectedEof`.
+    #[test]
+    fn test_streaming_input_and_decoding_via_next_row() {
+        const WIDTH: u32 = 16;
+        const IDAT_SIZE: usize = 512;
+        let streaming_input = StreamingInput::with_noncompressed_png(WIDTH, IDAT_SIZE);
+
+        let decoded_from_whole_input = streaming_input.decode_full_input(|mut r| {
+            let mut buf = vec![0; r.output_buffer_size()];
+            r.next_frame(&mut buf).unwrap();
+            buf
+        });
+
+        let mut png_reader = streaming_input.stream_input_until_reader_is_available();
+        let mut decoded_from_streaming_input = Vec::new();
+        loop {
+            match png_reader.next_row() {
+                Ok(None) => break,
+                Ok(Some(row)) => decoded_from_streaming_input.extend_from_slice(row.data()),
+                Err(DecodingError::IoError(e)) if e.kind() == ErrorKind::UnexpectedEof => {
+                    streaming_input.expose_next_byte()
+                }
+                e => panic!("Unexpected error: {:?}", e),
+            }
+        }
+        assert_eq!(
+            crc32fast::hash(&decoded_from_whole_input),
+            crc32fast::hash(&decoded_from_streaming_input)
+        );
+    }
+
+    /// Test resuming/retrying `Decoder.read_header_info` after `UnexpectedEof`.
+    #[test]
+    fn test_streaming_input_and_reading_header_info() {
+        const WIDTH: u32 = 16;
+        const IDAT_SIZE: usize = 512;
+        let streaming_input = StreamingInput::with_noncompressed_png(WIDTH, IDAT_SIZE);
+
+        let info_from_whole_input = streaming_input.decode_full_input(|r| r.info().clone());
+
+        let mut decoder = Decoder::new(streaming_input.clone());
+        let info_from_streaming_input = loop {
+            match decoder.read_header_info() {
+                Ok(info) => break info.clone(),
+                Err(DecodingError::IoError(e)) if e.kind() == ErrorKind::UnexpectedEof => {
+                    streaming_input.expose_next_byte()
+                }
+                e => panic!("Unexpected error: {:?}", e),
+            }
+        };
+
+        assert_eq!(info_from_whole_input.width, info_from_streaming_input.width);
+        assert_eq!(
+            info_from_whole_input.height,
+            info_from_streaming_input.height
+        );
+        assert_eq!(
+            info_from_whole_input.bit_depth,
+            info_from_streaming_input.bit_depth
+        );
+        assert_eq!(
+            info_from_whole_input.color_type,
+            info_from_streaming_input.color_type
+        );
+        assert_eq!(
+            info_from_whole_input.interlaced,
+            info_from_streaming_input.interlaced
+        );
+    }
 }
-- 
2.46.0.662.g92d0881bb0-goog

