From eebd5b2f43d635451a93fc6db6378ad8023a94f6 Mon Sep 17 00:00:00 2001
From: Lukasz Anforowicz <lukasza@chromium.org>
Date: Sun, 8 Sep 2024 20:40:17 +0000
Subject: [PATCH] Extract a separate `interlace_info.rs` module.

This commit decouples `fn next_pass` and `InterlaceIter` from the rest
of `mod.rs` - this coupling was mostly limited to 1) using
`self.subframe.rowlen` for `InterfaceInfo::Null` and 2) resetting
`self.prev_start` in-between Adam7 passes.  This decoupling allows
to encapsulate the related functionality inside a new
`interlace_info.rs` module.  This helps in follow-up commits, where
we want to refactor when exactly `Reader` advances that iterator.
---
 src/adam7.rs                  |  11 +--
 src/decoder/interlace_info.rs | 128 ++++++++++++++++++++++++++++++++++
 src/decoder/mod.rs            | 102 ++++++---------------------
 3 files changed, 154 insertions(+), 87 deletions(-)
 create mode 100644 src/decoder/interlace_info.rs

diff --git a/third_party/rust/chromium_crates_io/vendor/png-0.17.13/src/adam7.rs b/third_party/rust/chromium_crates_io/vendor/png-0.17.13/src/adam7.rs
index 8016b8b..75acf02 100644
--- a/third_party/rust/chromium_crates_io/vendor/png-0.17.13/src/adam7.rs
+++ b/third_party/rust/chromium_crates_io/vendor/png-0.17.13/src/adam7.rs
@@ -5,7 +5,7 @@
 /// [the Adam7 algorithm](https://en.wikipedia.org/wiki/Adam7_algorithm)
 /// applies to a decoded row.
 ///
-/// See also [crate::decoder::Reader::next_interlaced_row].
+/// See also [Reader.next_interlaced_row](crate::decoder::Reader::next_interlaced_row).
 #[derive(Clone, Copy, Debug, PartialEq, Eq)]
 pub struct Adam7Info {
     pub(crate) pass: u8,
@@ -27,10 +27,10 @@ impl Adam7Info {
     ///   in the 1st `pass`, the `width` is be 1/8th of the image width (rounded up as
     ///   necessary).
     ///
-    /// Note that in typical usage, `Adam7Info`s are returned by [Reader::next_interlaced_row]
+    /// Note that in typical usage, `Adam7Info`s are returned by [Reader.next_interlaced_row]
     /// and there is no need to create them by calling `Adam7Info::new`.  `Adam7Info::new` is
     /// nevertheless exposed as a public API, because it helps to provide self-contained example
-    /// usage of [expand_interlaced_row].
+    /// usage of [expand_interlaced_row](crate::expand_interlaced_row).
     pub fn new(pass: u8, line: u32, width: u32) -> Self {
         assert!(1 <= pass && pass <= 7);
         assert!(width > 0);
@@ -92,11 +92,6 @@ impl Adam7Iterator {
         self.lines = lines.ceil() as u32;
         self.line = 0;
     }
-
-    /// The current pass#.
-    pub fn current_pass(&self) -> u8 {
-        self.current_pass
-    }
 }
 
 /// Iterates over `Adam7Info`s.
diff --git a/third_party/rust/chromium_crates_io/vendor/png-0.17.13/src/decoder/interlace_info.rs b/third_party/rust/chromium_crates_io/vendor/png-0.17.13/src/decoder/interlace_info.rs
new file mode 100644
index 0000000..4201fff
--- /dev/null
+++ b/third_party/rust/chromium_crates_io/vendor/png-0.17.13/src/decoder/interlace_info.rs
@@ -0,0 +1,128 @@
+use std::ops::Range;
+
+use crate::adam7::{Adam7Info, Adam7Iterator};
+
+/// Describes which interlacing algorithm applies to a decoded row.
+///
+/// PNG (2003) specifies two interlace modes, but reserves future extensions.
+///
+/// See also [Reader.next_interlaced_row](crate::Reader::next_interlaced_row).
+#[derive(Clone, Copy, Debug)]
+pub enum InterlaceInfo {
+    /// The `null` method means no interlacing.
+    Null(NullInfo),
+    /// [The `Adam7` algorithm](https://en.wikipedia.org/wiki/Adam7_algorithm) derives its name
+    /// from doing 7 passes over the image, only decoding a subset of all pixels in each pass.
+    /// The following table shows pictorially what parts of each 8x8 area of the image is found in
+    /// each pass:
+    ///
+    /// ```txt
+    /// 1 6 4 6 2 6 4 6
+    /// 7 7 7 7 7 7 7 7
+    /// 5 6 5 6 5 6 5 6
+    /// 7 7 7 7 7 7 7 7
+    /// 3 6 4 6 3 6 4 6
+    /// 7 7 7 7 7 7 7 7
+    /// 5 6 5 6 5 6 5 6
+    /// 7 7 7 7 7 7 7 7
+    /// ```
+    Adam7(Adam7Info),
+}
+
+#[derive(Clone, Copy, Debug)]
+pub struct NullInfo {
+    line: u32,
+}
+
+impl InterlaceInfo {
+    pub(crate) fn line_number(&self) -> u32 {
+        match self {
+            InterlaceInfo::Null(NullInfo { line }) => *line,
+            InterlaceInfo::Adam7(Adam7Info { line, .. }) => *line,
+        }
+    }
+
+    pub(crate) fn get_adam7_info(&self) -> Option<&Adam7Info> {
+        match self {
+            InterlaceInfo::Null(_) => None,
+            InterlaceInfo::Adam7(adam7info) => Some(adam7info),
+        }
+    }
+}
+
+pub(crate) struct InterlaceInfoIter(IterImpl);
+
+impl InterlaceInfoIter {
+    pub fn empty() -> Self {
+        Self(IterImpl::None(0..0))
+    }
+
+    pub fn new(width: u32, height: u32, interlaced: bool) -> Self {
+        if interlaced {
+            Self(IterImpl::Adam7(Adam7Iterator::new(width, height)))
+        } else {
+            Self(IterImpl::None(0..height))
+        }
+    }
+}
+
+impl Iterator for InterlaceInfoIter {
+    type Item = InterlaceInfo;
+
+    fn next(&mut self) -> Option<InterlaceInfo> {
+        match self.0 {
+            IterImpl::Adam7(ref mut adam7) => Some(InterlaceInfo::Adam7(adam7.next()?)),
+            IterImpl::None(ref mut height) => Some(InterlaceInfo::Null(NullInfo {
+                line: height.next()?,
+            })),
+        }
+    }
+}
+
+enum IterImpl {
+    None(Range<u32>),
+    Adam7(Adam7Iterator),
+}
+
+#[cfg(test)]
+mod test {
+    use super::*;
+
+    #[test]
+    fn null() {
+        assert_eq!(
+            InterlaceInfoIter::new(8, 8, false)
+                .map(|info| info.line_number())
+                .collect::<Vec<_>>(),
+            vec![0, 1, 2, 3, 4, 5, 6, 7],
+        );
+    }
+
+    #[test]
+    fn adam7() {
+        assert_eq!(
+            InterlaceInfoIter::new(8, 8, true)
+                .map(|info| info.line_number())
+                .collect::<Vec<_>>(),
+            vec![
+                0, // pass 1
+                0, // pass 2
+                0, // pass 3
+                0, 1, // pass 4
+                0, 1, // pass 5
+                0, 1, 2, 3, // pass 6
+                0, 1, 2, 3, // pass 7
+            ],
+        );
+    }
+
+    #[test]
+    fn empty() {
+        assert_eq!(
+            InterlaceInfoIter::empty()
+                .map(|info| info.line_number())
+                .collect::<Vec<_>>(),
+            vec![],
+        );
+    }
+}
diff --git a/third_party/rust/chromium_crates_io/vendor/png-0.17.13/src/decoder/mod.rs b/third_party/rust/chromium_crates_io/vendor/png-0.17.13/src/decoder/mod.rs
index 8f50e9b..abe94c1 100644
--- a/third_party/rust/chromium_crates_io/vendor/png-0.17.13/src/decoder/mod.rs
+++ b/third_party/rust/chromium_crates_io/vendor/png-0.17.13/src/decoder/mod.rs
@@ -1,3 +1,4 @@
+mod interlace_info;
 mod stream;
 pub(crate) mod transform;
 mod zlib;
@@ -8,15 +9,17 @@ use self::transform::{create_transform_fn, TransformFn};
 
 use std::io::{BufRead, BufReader, Read};
 use std::mem;
-use std::ops::Range;
 
-use crate::adam7;
+use crate::adam7::{self, Adam7Info};
 use crate::chunk;
 use crate::common::{
     BitDepth, BytesPerPixel, ColorType, Info, ParameterErrorKind, Transformations,
 };
 use crate::filter::{unfilter, FilterType};
 
+pub use interlace_info::InterlaceInfo;
+use interlace_info::InterlaceInfoIter;
+
 /*
 pub enum InterlaceHandling {
     /// Outputs the raw rows
@@ -104,42 +107,6 @@ impl<'data> InterlacedRow<'data> {
     }
 }
 
-/// Describes which interlacing algorithm applies to a decoded row.
-///
-/// PNG (2003) specifies two interlace modes, but reserves future extensions.
-///
-/// See also [Reader::next_interlaced_row].
-#[derive(Clone, Copy, Debug)]
-pub enum InterlaceInfo {
-    /// The `null` method means no interlacing.
-    Null,
-    /// [The `Adam7` algorithm](https://en.wikipedia.org/wiki/Adam7_algorithm) derives its name
-    /// from doing 7 passes over the image, only decoding a subset of all pixels in each pass.
-    /// The following table shows pictorially what parts of each 8x8 area of the image is found in
-    /// each pass:
-    ///
-    /// ```txt
-    /// 1 6 4 6 2 6 4 6
-    /// 7 7 7 7 7 7 7 7
-    /// 5 6 5 6 5 6 5 6
-    /// 7 7 7 7 7 7 7 7
-    /// 3 6 4 6 3 6 4 6
-    /// 7 7 7 7 7 7 7 7
-    /// 5 6 5 6 5 6 5 6
-    /// 7 7 7 7 7 7 7 7
-    /// ```
-    Adam7(adam7::Adam7Info),
-}
-
-impl InterlaceInfo {
-    fn get_adam7_info(&self) -> Option<&adam7::Adam7Info> {
-        match self {
-            InterlaceInfo::Null => None,
-            InterlaceInfo::Adam7(adam7info) => Some(adam7info),
-        }
-    }
-}
-
 /// A row of data without interlace information.
 #[derive(Clone, Copy, Debug)]
 pub struct Row<'data> {
@@ -422,16 +389,10 @@ struct SubframeInfo {
     width: u32,
     height: u32,
     rowlen: usize,
-    interlace: InterlaceIter,
+    interlace: InterlaceInfoIter,
     consumed_and_flushed: bool,
 }
 
-#[derive(Clone)]
-enum InterlaceIter {
-    None(Range<u32>),
-    Adam7(adam7::Adam7Iterator),
-}
-
 /// Denote a frame as given by sequence numbers.
 #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]
 enum SubframeIdx {
@@ -565,7 +526,7 @@ impl<R: Read> Reader<R> {
             {
                 // `unwrap` won't panic, because we checked `self.info().interlaced` above.
                 let adam7info = interlace.get_adam7_info().unwrap();
-                adam7::expand_pass(buf, stride, row, &adam7info, bits_pp);
+                adam7::expand_pass(buf, stride, row, adam7info, bits_pp);
             }
         } else {
             for row in buf
@@ -610,15 +571,22 @@ impl<R: Read> Reader<R> {
 
     /// Returns the next processed row of the image
     pub fn next_interlaced_row(&mut self) -> Result<Option<InterlacedRow>, DecodingError> {
-        let (rowlen, interlace) = match self.next_pass() {
-            Some((rowlen, interlace)) => (rowlen, interlace),
+        let interlace = match self.subframe.interlace.next() {
             None => return Ok(None),
+            Some(interlace) => interlace,
         };
-
-        let width = if let InterlaceInfo::Adam7(adam7::Adam7Info { width, .. }) = interlace {
-            width
-        } else {
-            self.subframe.width
+        if interlace.line_number() == 0 {
+            self.prev_start = self.current_start;
+        }
+        let rowlen = match interlace {
+            InterlaceInfo::Null(_) => self.subframe.rowlen,
+            InterlaceInfo::Adam7(Adam7Info { width, .. }) => {
+                self.info().raw_row_length_from_width(width)
+            }
+        };
+        let width = match interlace {
+            InterlaceInfo::Adam7(Adam7Info { width, .. }) => width,
+            InterlaceInfo::Null(_) => self.subframe.width,
         };
         let output_line_size = self.output_line_size(width);
 
@@ -727,24 +695,6 @@ impl<R: Read> Reader<R> {
         color.raw_row_length_from_width(depth, width) - 1
     }
 
-    fn next_pass(&mut self) -> Option<(usize, InterlaceInfo)> {
-        match self.subframe.interlace {
-            InterlaceIter::Adam7(ref mut adam7) => {
-                let last_pass = adam7.current_pass();
-                let adam7info = adam7.next()?;
-                let rowlen = self.info().raw_row_length_from_width(adam7info.width);
-                if last_pass != adam7info.pass {
-                    self.prev_start = self.current_start;
-                }
-                Some((rowlen, InterlaceInfo::Adam7(adam7info)))
-            }
-            InterlaceIter::None(ref mut height) => {
-                let _ = height.next()?;
-                Some((self.subframe.rowlen, InterlaceInfo::Null))
-            }
-        }
-    }
-
     /// Write the next raw interlaced row into `self.prev`.
     ///
     /// The scanline is filtered against the previous scanline according to the specification.
@@ -812,7 +762,7 @@ impl SubframeInfo {
             width: 0,
             height: 0,
             rowlen: 0,
-            interlace: InterlaceIter::None(0..0),
+            interlace: InterlaceInfoIter::empty(),
             consumed_and_flushed: false,
         }
     }
@@ -826,17 +776,11 @@ impl SubframeInfo {
             (info.width, info.height)
         };
 
-        let interlace = if info.interlaced {
-            InterlaceIter::Adam7(adam7::Adam7Iterator::new(width, height))
-        } else {
-            InterlaceIter::None(0..height)
-        };
-
         SubframeInfo {
             width,
             height,
             rowlen: info.raw_row_length_from_width(width),
-            interlace,
+            interlace: InterlaceInfoIter::new(width, height, info.interlaced),
             consumed_and_flushed: false,
         }
     }
-- 
2.46.0.662.g92d0881bb0-goog

