From b5b0674a0cd50a1f3c1e09f699c04b168648a237 Mon Sep 17 00:00:00 2001
From: Lukasz Anforowicz <lukasza@chromium.org>
Date: Sun, 8 Sep 2024 20:02:54 +0000
Subject: [PATCH 202/203] Support for detecting an unexpected EOF using the
 public API.

This commit supports detecting unexpected EOF using the public API of of
`DecodingError`.  Before this commit `UnexpectedEof`,
`UnexpectedEndOfChunk`, and `NoMoreImageData` errors were represented as
a crate-internal `FormatErrorInner` type.  After this commit, these
errors have a representation that can be detected using the public API:
`DecodingError::IoError(std::io::ErrorKind::UnexpectedEof.into())`.
---
 src/decoder/mod.rs    | 31 +++++++------------------------
 src/decoder/stream.rs | 12 ------------
 2 files changed, 7 insertions(+), 36 deletions(-)

diff --git a/third_party/rust/chromium_crates_io/vendor/png-0.17.13/src/decoder/mod.rs b/third_party/rust/chromium_crates_io/vendor/png-0.17.13/src/decoder/mod.rs
index abe94c1..94a95bb 100644
--- a/third_party/rust/chromium_crates_io/vendor/png-0.17.13/src/decoder/mod.rs
+++ b/third_party/rust/chromium_crates_io/vendor/png-0.17.13/src/decoder/mod.rs
@@ -191,9 +191,7 @@ impl<R: Read> Decoder<R> {
         while self.read_decoder.info().is_none() {
             buf.clear();
             if self.read_decoder.decode_next(&mut buf)?.is_none() {
-                return Err(DecodingError::Format(
-                    FormatErrorInner::UnexpectedEof.into(),
-                ));
+                return Err(DecodingError::IoError(std::io::ErrorKind::UnexpectedEof.into()));
             }
         }
         Ok(self.read_decoder.info().unwrap())
@@ -303,9 +301,7 @@ impl<R: Read> ReadDecoder<R> {
             let (consumed, result) = {
                 let buf = self.reader.fill_buf()?;
                 if buf.is_empty() {
-                    return Err(DecodingError::Format(
-                        FormatErrorInner::UnexpectedEof.into(),
-                    ));
+                    return Err(DecodingError::IoError(std::io::ErrorKind::UnexpectedEof.into()));
                 }
                 self.decoder.update(buf, image_data)?
             };
@@ -323,9 +319,7 @@ impl<R: Read> ReadDecoder<R> {
         while !self.at_eof {
             let buf = self.reader.fill_buf()?;
             if buf.is_empty() {
-                return Err(DecodingError::Format(
-                    FormatErrorInner::UnexpectedEof.into(),
-                ));
+                return Err(DecodingError::IoError(std::io::ErrorKind::UnexpectedEof.into()));
             }
             let (consumed, event) = self.decoder.update(buf, &mut vec![])?;
             self.reader.consume(consumed);
@@ -340,9 +334,7 @@ impl<R: Read> ReadDecoder<R> {
             }
         }
 
-        Err(DecodingError::Format(
-            FormatErrorInner::UnexpectedEof.into(),
-        ))
+        Err(DecodingError::IoError(std::io::ErrorKind::UnexpectedEof.into()))
     }
 
     fn info(&self) -> Option<&Info<'static>> {
@@ -702,9 +694,7 @@ impl<R: Read> Reader<R> {
         // Read image data until we have at least one full row (but possibly more than one).
         while self.data_stream.len() - self.current_start < rowlen {
             if self.subframe.consumed_and_flushed {
-                return Err(DecodingError::Format(
-                    FormatErrorInner::NoMoreImageData.into(),
-                ));
+                return Err(DecodingError::IoError(std::io::ErrorKind::UnexpectedEof.into()));
             }
 
             // Clear the current buffer before appending more data.
@@ -722,14 +712,7 @@ impl<R: Read> Reader<R> {
                     self.subframe.consumed_and_flushed = true;
                 }
                 None => {
-                    return Err(DecodingError::Format(
-                        if self.data_stream.is_empty() {
-                            FormatErrorInner::NoMoreImageData
-                        } else {
-                            FormatErrorInner::UnexpectedEndOfChunk
-                        }
-                        .into(),
-                    ));
+                    return Err(DecodingError::IoError(std::io::ErrorKind::UnexpectedEof.into()));
                 }
                 _ => (),
             }
diff --git a/third_party/rust/chromium_crates_io/vendor/png-0.17.13/src/decoder/stream.rs b/third_party/rust/chromium_crates_io/vendor/png-0.17.13/src/decoder/stream.rs
index 0f0c58d..3b6ccb6 100644
--- a/third_party/rust/chromium_crates_io/vendor/png-0.17.13/src/decoder/stream.rs
+++ b/third_party/rust/chromium_crates_io/vendor/png-0.17.13/src/decoder/stream.rs
@@ -160,10 +160,6 @@ pub(crate) enum FormatErrorInner {
     },
     /// Not a PNG, the magic signature is missing.
     InvalidSignature,
-    /// End of file, within a chunk event.
-    UnexpectedEof,
-    /// End of file, while expecting more image data.
-    UnexpectedEndOfChunk,
     // Errors of chunk level ordering, missing etc.
     /// Ihdr must occur.
     MissingIhdr,
@@ -232,8 +228,6 @@ pub(crate) enum FormatErrorInner {
     CorruptFlateStream {
         err: fdeflate::DecompressionError,
     },
-    /// The image data chunk was too short for the expected pixel count.
-    NoMoreImageData,
     /// Bad text encoding
     BadTextEncoding(TextDecodingError),
     /// fdAT shorter than 4 bytes
@@ -323,9 +317,6 @@ impl fmt::Display for FormatError {
             UnknownInterlaceMethod(nr) => write!(fmt, "Unknown interlace method {}.", nr),
             BadSubFrameBounds {} => write!(fmt, "Sub frame is out-of-bounds."),
             InvalidSignature => write!(fmt, "Invalid PNG signature."),
-            UnexpectedEof => write!(fmt, "Unexpected end of data before image end."),
-            UnexpectedEndOfChunk => write!(fmt, "Unexpected end of data within a chunk."),
-            NoMoreImageData => write!(fmt, "IDAT or fDAT chunk is has not enough data for image."),
             CorruptFlateStream { err } => {
                 write!(fmt, "Corrupt deflate stream. ")?;
                 write!(fmt, "{:?}", err)
-- 
2.46.0.662.g92d0881bb0-goog

