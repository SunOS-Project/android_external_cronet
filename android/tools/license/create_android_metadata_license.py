import license_utils
import sys
from mapper import Mapper
import os
import glob
from typing import Dict, Callable, List
from pathlib import Path
from license_type import LicenseType

# This is relative to the repo_directory passed in |update_license|
_IGNORED_README = {
    # Not a third-party.
    "testing/android/native_test/README.chromium",
    # Not a third-party.
    "build/internal/README.chromium",
}

METADATA_HEADER = """# This was automatically generated by {}
# This directory was imported from Chromium.""".format(
    os.path.basename(__file__))

_ROOT_CRONET = os.path.abspath(
    os.path.join(os.path.dirname(__file__), os.path.pardir, os.path.pardir,
                 os.path.pardir))

# This is relative to the repo_directory passed in |update_license|
# post-processing is necessary for the cases where the license is not in the
# standard format, this can include two or more license (eg: "Apache 2 and MPL")
# or a single license that is not easily identifiable (eg: "BSDish")
#
# The current structure is Mapper(dictionary_key, expected_value, value_to_write)
_POST_PROCESS_OPERATION = {
    "base/third_party/nspr/README.chromium": license_utils.create_license_post_processing(
        Mapper("License", ['MPL 1.1/GPL 2.0/LGPL 2.1'], ["MPL 1.1"])),
    "url/third_party/mozilla/README.chromium": license_utils.create_license_post_processing(
        Mapper("License", ['BSD and MPL 1.1/GPL 2.0/LGPL 2.1'],
               ["BSD"])),
    "third_party/libc++abi/README.chromium": license_utils.create_license_post_processing(
        Mapper("License",
               ['MIT',
                'University of Illinois/NCSA Open Source License'],
               ["MIT"])),
    "third_party/libc++/README.chromium": license_utils.create_license_post_processing(
        Mapper("License",
               ['MIT',
                'University of Illinois/NCSA Open Source License'],
               ["MIT"])),
    "third_party/boringssl/README.chromium": license_utils.create_license_post_processing(
        Mapper("License", ['BSDish'], ["BSD"]),
        # TODO(b/360316861): Fix upstream by setting an explicit version to boringssl.
        Mapper("Version", "git", None)),
    "net/third_party/quiche/METADATA": license_utils.create_license_post_processing(
        # TODO(b/360316861): Fix upstream by setting an explicit version to QUICHE.
        Mapper("Version", "git", None)),
    # TODO(b/360316861): Fix this upstream in Chromium.
    "third_party/quic_trace/README.chromium": license_utils.create_license_post_processing(
        Mapper("Version", "git", "caa0a6eaba816ecb737f9a70782b7c80b8ac8dbc")),
    "third_party/metrics_proto/README.chromium": license_utils.create_license_post_processing(
        Mapper("URL", "This is the canonical public repository", "Piper")),
    "third_party/boringssl/src/pki/testdata/nist-pkits/README.chromium": license_utils.create_license_post_processing(
        Mapper("License", [
            'Public Domain: United States Government Work under 17 U.S.C. 105'],
               ["unencumbered"]),
        Mapper("License File", "", "N/A")),
}


def _create_metadata_file(repo_path: str, directory_path: str, content: str,
    verify_only: bool):
  """Creates a METADATA file with a header to ensure that this was generated
  through the script. If the header is not found then it is assumed that the
  METADATA file is created manually and will not be touched."""
  metadata = Path(os.path.join(directory_path, "METADATA"))
  if metadata.is_file() and METADATA_HEADER not in metadata.read_text():
    # This is a manually created file! Don't overwrite.
    return

  metadata_content = "\n".join([
      METADATA_HEADER,
      content
  ])
  if verify_only:
    if not metadata.exists():
      raise Exception(
          f"Failed to find metadata file {metadata.relative_to(repo_path)}")
    if not metadata.read_text() == metadata_content:
      raise Exception(
          f"Metadata content of {metadata.relative_to(repo_path)} does not match the expected."
          f"Please re-run create_android_metadata_license.py")
  else:
    metadata.write_text(metadata_content)


def _create_module_license_file(repo_path: str, directory_path: str,
    licenses: List[str],
    verify_only: bool):
  """Creates a MODULE_LICENSE_XYZ files."""
  for license in licenses:
    license_file = Path(os.path.join(directory_path,
                                     f"MODULE_LICENSE_{license_utils.get_license_file_format(license)}"))
    if verify_only:
      if not license_file.exists():
        raise Exception(
            f"Failed to find module file {license_file.relative_to(repo_path)}")
    else:
      license_file.touch()


def _maybe_create_license_file_symlink(repo_path: str, directory_path: str,
    original_license_file: str,
    verify_only: bool):
  """Creates a LICENSE symbolic link only if it doesn't exist."""
  if original_license_file == "LICENSE":
    # This means that there already exists a LICENSE file at the same directory
    # that we are trying to create our symlink. Do nothing.
    return
  license_symlink_path = Path(os.path.join(directory_path, "LICENSE"))
  if license_symlink_path.exists():
    # The symlink is already there, skip.
    return

  if verify_only:
    if not license_symlink_path.exists():
      raise Exception(
          f"License symlink does not exist for {license_symlink_path}")
  else:
    os.symlink(original_license_file, license_symlink_path)


def get_all_readme(repo_path: str):
  """Fetches all README.chromium files under |repo_path|."""
  return glob.glob("**/README.chromium", root_dir=repo_path, recursive=True)


def update_license(repo_path: str = _ROOT_CRONET,
    post_process_dict: Dict[str, Callable] = _POST_PROCESS_OPERATION,
    verify_only: bool = False):
  """
  Updates the licensing files for the entire repository of external/cronet.

  Running this will generate the following files for each README.chromium

  * LICENSE, this is a symbolic link and only created if there is no LICENSE
  file already.
  * METADATA
  * MODULE_LICENSE_XYZ, XYZ represents the license found in README.chromium.

  Running in verify-only mode will ensure that everything is up to date, an
  exception will be thrown if there needs to be any changes.
  :param repo_path: Absolute path to Cronet's AOSP repository
  :param post_process_dict: A dictionary that includes post-processing, this
  post processing is not done on the README.chromium file but on the Metadata
  structure that is extracted from them.
  :param verify_only: Ensures that everything is up to date or throws.
  """
  readme_files = get_all_readme(repo_path)
  if readme_files == 0:
    raise Exception(
        f"Failed to find any README.chromium files under {repo_path}")

  for readme_file in readme_files:
    if readme_file in _IGNORED_README:
      continue
    readme_directory = os.path.dirname(
        os.path.abspath(os.path.join(repo_path, readme_file)))

    metadata = license_utils.parse_chromium_readme_file(
        os.path.abspath(os.path.join(repo_path, readme_file)),
        post_process_dict.get(
            readme_file,
            lambda
                _metadata: _metadata))

    if metadata.get_license_type() != LicenseType.UNENCUMBERED:
      # Unencumbered license are public domains or don't have a license.
      _maybe_create_license_file_symlink(repo_path, readme_directory,
                                         license_utils.resolve_license_path(
                                             repo_path,
                                             metadata.get_license_file_path()),
                                         verify_only)
    _create_module_license_file(repo_path, readme_directory,
                                metadata.get_licenses(), verify_only)
    _create_metadata_file(repo_path, readme_directory,
                          metadata.to_android_metadata(), verify_only)


if __name__ == '__main__':
  sys.exit(update_license(post_process_dict=_POST_PROCESS_OPERATION))
